{
  "name": "External Integrations Sync Pipeline",
  "nodes": [
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "cronExpression",
              "expression": "0 */4 * * *"
            }
          ]
        }
      },
      "id": "sync-schedule",
      "name": "Sync Schedule (Every 4 hours)",
      "type": "n8n-nodes-base.cron",
      "typeVersion": 1,
      "position": [240, 300]
    },
    {
      "parameters": {
        "url": "={{$env.API_BASE_URL}}/integrations/active",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "httpBearerAuth",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "options": {}
      },
      "id": "get-active-integrations",
      "name": "Get Active Integrations",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [460, 300],
      "credentials": {
        "httpBearerAuth": {
          "id": "api-token",
          "name": "API Token"
        }
      }
    },
    {
      "parameters": {
        "batchSize": 5,
        "options": {}
      },
      "id": "split-integrations",
      "name": "Split into Batches",
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [680, 300]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "healthkit-type",
              "leftValue": "={{$json.type}}",
              "rightValue": "healthkit",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            },
            {
              "id": "googlefit-type",
              "leftValue": "={{$json.type}}",
              "rightValue": "googlefit",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            },
            {
              "id": "fitbit-type",
              "leftValue": "={{$json.type}}",
              "rightValue": "fitbit",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            }
          ],
          "combinator": "or"
        },
        "options": {}
      },
      "id": "check-health-integration",
      "name": "Check Health Integration Type",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [900, 300]
    },
    {
      "parameters": {
        "options": {}
      },
      "id": "sync-health-data",
      "name": "Sync Health & Fitness Data",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [1120, 200],
      "code": "// Sync health and fitness data from wearables/health apps\nconst integration = $input.first().json;\nconst userId = integration.userId;\nconst integrationType = integration.type;\nconst accessToken = integration.accessToken;\nconst lastSyncTime = integration.lastSyncTime || new Date(Date.now() - 24*60*60*1000).toISOString(); // Default to 24h ago\n\n// Define endpoints and data mappings for different integrations\nconst integrationConfigs = {\n  healthkit: {\n    baseUrl: 'https://api.healthkit.com',\n    endpoints: {\n      steps: '/v1/steps',\n      heartRate: '/v1/heart-rate',\n      sleep: '/v1/sleep',\n      weight: '/v1/weight',\n      bloodPressure: '/v1/blood-pressure',\n      bloodGlucose: '/v1/blood-glucose'\n    },\n    headers: {\n      'Authorization': `Bearer ${accessToken}`,\n      'Content-Type': 'application/json'\n    }\n  },\n  googlefit: {\n    baseUrl: 'https://www.googleapis.com/fitness/v1/users/me',\n    endpoints: {\n      steps: '/dataSources/derived:com.google.step_count.delta:com.google.android.gms:estimated_steps/datasets',\n      heartRate: '/dataSources/derived:com.google.heart_rate.bpm:com.google.android.gms:merge_heart_rate_bpm/datasets',\n      calories: '/dataSources/derived:com.google.calories.expended:com.google.android.gms:merge_calories_expended/datasets',\n      weight: '/dataSources/derived:com.google.weight:com.google.android.gms:merge_weight/datasets'\n    },\n    headers: {\n      'Authorization': `Bearer ${accessToken}`,\n      'Content-Type': 'application/json'\n    }\n  },\n  fitbit: {\n    baseUrl: 'https://api.fitbit.com/1/user/-',\n    endpoints: {\n      steps: '/activities/date/{{date}}.json',\n      heartRate: '/activities/heart/date/{{date}}/1d.json',\n      sleep: '/sleep/date/{{date}}.json',\n      weight: '/body/log/weight/date/{{date}}.json'\n    },\n    headers: {\n      'Authorization': `Bearer ${accessToken}`,\n      'Content-Type': 'application/json'\n    }\n  }\n};\n\nconst config = integrationConfigs[integrationType];\nif (!config) {\n  throw new Error(`Unsupported integration type: ${integrationType}`);\n}\n\n// Calculate date range for sync\nconst startDate = new Date(lastSyncTime);\nconst endDate = new Date();\nconst dateRange = {\n  start: startDate.toISOString(),\n  end: endDate.toISOString(),\n  startMillis: startDate.getTime(),\n  endMillis: endDate.getTime()\n};\n\n// Prepare sync requests for different data types\nconst syncRequests = [];\n\nObject.keys(config.endpoints).forEach(dataType => {\n  let endpoint = config.endpoints[dataType];\n  \n  // Handle date placeholders for Fitbit\n  if (integrationType === 'fitbit') {\n    endpoint = endpoint.replace('{{date}}', endDate.toISOString().split('T')[0]);\n  }\n  \n  // Handle Google Fit dataset ranges\n  if (integrationType === 'googlefit') {\n    endpoint += `/${dateRange.startMillis}000000-${dateRange.endMillis}000000`;\n  }\n  \n  syncRequests.push({\n    dataType: dataType,\n    url: `${config.baseUrl}${endpoint}`,\n    headers: config.headers,\n    params: integrationType === 'healthkit' ? {\n      start_date: dateRange.start,\n      end_date: dateRange.end\n    } : {}\n  });\n});\n\nreturn {\n  userId: userId,\n  integrationType: integrationType,\n  integrationId: integration.id,\n  syncRequests: syncRequests,\n  dateRange: dateRange,\n  syncStarted: new Date().toISOString()\n};"
    },
    {
      "parameters": {
        "url": "={{$env.WEATHER_API_URL}}/current",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "httpHeaderAuth",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "lat",
              "value": "={{$json.location.latitude}}"
            },
            {
              "name": "lon",
              "value": "={{$json.location.longitude}}"
            },
            {
              "name": "appid",
              "value": "={{$env.OPENWEATHER_API_KEY}}"
            },
            {
              "name": "units",
              "value": "metric"
            }
          ]
        },
        "options": {}
      },
      "id": "sync-weather-data",
      "name": "Sync Weather & AQI Data",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [1120, 400],
      "credentials": {
        "httpHeaderAuth": {
          "id": "weather-api-key",
          "name": "Weather API Key"
        }
      }
    },
    {
      "parameters": {
        "options": {}
      },
      "id": "process-health-data",
      "name": "Process Health Data",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [1340, 200],
      "code": "// Process and normalize health data from various sources\nconst syncData = $input.first().json;\nconst userId = syncData.userId;\nconst integrationType = syncData.integrationType;\n\n// Mock successful sync responses for demonstration\n// In real implementation, you would make actual HTTP requests to the APIs\nconst mockResponses = {\n  healthkit: {\n    steps: { data: [{ date: '2024-01-15', value: 8432, source: 'iPhone' }] },\n    heartRate: { data: [{ timestamp: '2024-01-15T10:30:00Z', value: 72, context: 'resting' }] },\n    sleep: { data: [{ date: '2024-01-15', duration: 450, quality: 'good', deep: 120, rem: 90 }] },\n    weight: { data: [{ date: '2024-01-15', value: 68.5, unit: 'kg' }] }\n  },\n  googlefit: {\n    steps: { point: [{ value: [{ intVal: 8234 }], startTimeNanos: '1642233600000000000' }] },\n    heartRate: { point: [{ value: [{ fpVal: 74.5 }], startTimeNanos: '1642233600000000000' }] },\n    calories: { point: [{ value: [{ fpVal: 2150 }], startTimeNanos: '1642233600000000000' }] }\n  },\n  fitbit: {\n    steps: { summary: { steps: 8156 }, activities: [] },\n    heartRate: { 'activities-heart': [{ value: { restingHeartRate: 68 } }] },\n    sleep: { sleep: [{ duration: 26400000, efficiency: 87 }] },\n    weight: { weight: [{ weight: 69.2, date: '2024-01-15' }] }\n  }\n};\n\n// Normalize data to common format\nfunction normalizeHealthData(responses, type) {\n  const normalized = {\n    userId: userId,\n    source: type,\n    syncTimestamp: new Date().toISOString(),\n    data: {}\n  };\n  \n  switch (type) {\n    case 'healthkit':\n      if (responses.steps?.data) {\n        normalized.data.steps = responses.steps.data.map(item => ({\n          date: item.date,\n          value: item.value,\n          source: item.source\n        }));\n      }\n      if (responses.heartRate?.data) {\n        normalized.data.heartRate = responses.heartRate.data.map(item => ({\n          timestamp: item.timestamp,\n          value: item.value,\n          context: item.context\n        }));\n      }\n      if (responses.sleep?.data) {\n        normalized.data.sleep = responses.sleep.data.map(item => ({\n          date: item.date,\n          totalMinutes: item.duration,\n          quality: item.quality,\n          deepMinutes: item.deep,\n          remMinutes: item.rem\n        }));\n      }\n      if (responses.weight?.data) {\n        normalized.data.weight = responses.weight.data.map(item => ({\n          date: item.date,\n          value: item.value,\n          unit: item.unit\n        }));\n      }\n      break;\n      \n    case 'googlefit':\n      if (responses.steps?.point) {\n        normalized.data.steps = responses.steps.point.map(point => ({\n          timestamp: new Date(parseInt(point.startTimeNanos) / 1000000).toISOString(),\n          value: point.value[0].intVal,\n          source: 'Google Fit'\n        }));\n      }\n      if (responses.heartRate?.point) {\n        normalized.data.heartRate = responses.heartRate.point.map(point => ({\n          timestamp: new Date(parseInt(point.startTimeNanos) / 1000000).toISOString(),\n          value: point.value[0].fpVal,\n          context: 'recorded'\n        }));\n      }\n      break;\n      \n    case 'fitbit':\n      if (responses.steps?.summary) {\n        normalized.data.steps = [{\n          date: new Date().toISOString().split('T')[0],\n          value: responses.steps.summary.steps,\n          source: 'Fitbit'\n        }];\n      }\n      if (responses.heartRate?.['activities-heart']) {\n        const hrData = responses.heartRate['activities-heart'][0];\n        if (hrData?.value?.restingHeartRate) {\n          normalized.data.heartRate = [{\n            timestamp: new Date().toISOString(),\n            value: hrData.value.restingHeartRate,\n            context: 'resting'\n          }];\n        }\n      }\n      break;\n  }\n  \n  return normalized;\n}\n\n// Process the mock responses\nconst responses = mockResponses[integrationType] || {};\nconst normalizedData = normalizeHealthData(responses, integrationType);\n\n// Calculate health insights\nconst insights = {\n  dailySteps: normalizedData.data.steps?.[0]?.value || 0,\n  avgHeartRate: normalizedData.data.heartRate?.reduce((sum, hr) => sum + hr.value, 0) / (normalizedData.data.heartRate?.length || 1) || null,\n  sleepQuality: normalizedData.data.sleep?.[0]?.quality || null,\n  weightTrend: normalizedData.data.weight?.length > 1 ? 'stable' : null\n};\n\nreturn {\n  ...syncData,\n  normalizedData: normalizedData,\n  insights: insights,\n  processed: true,\n  processedAt: new Date().toISOString()\n};"
    },
    {
      "parameters": {
        "url": "={{$env.API_BASE_URL}}/integrations/data/store",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "httpBearerAuth",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "userId",
              "value": "={{$json.userId}}"
            },
            {
              "name": "integrationId",
              "value": "={{$json.integrationId}}"
            },
            {
              "name": "integrationType",
              "value": "={{$json.integrationType}}"
            },
            {
              "name": "data",
              "value": "={{$json.normalizedData}}"
            },
            {
              "name": "insights",
              "value": "={{$json.insights}}"
            },
            {
              "name": "weatherData",
              "value": "={{$('Sync Weather & AQI Data').first() ? $('Sync Weather & AQI Data').first().json : null}}"
            },
            {
              "name": "syncTimestamp",
              "value": "={{$json.processedAt}}"
            }
          ]
        },
        "options": {}
      },
      "id": "store-sync-data",
      "name": "Store Sync Data",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [1560, 300],
      "credentials": {
        "httpBearerAuth": {
          "id": "api-token",
          "name": "API Token"
        }
      }
    },
    {
      "parameters": {
        "url": "={{$env.API_BASE_URL}}/integrations/{{$json.integrationId}}/status",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "httpBearerAuth",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "lastSyncTime",
              "value": "={{$('Store Sync Data').first().json.syncTimestamp}}"
            },
            {
              "name": "status",
              "value": "active"
            },
            {
              "name": "dataPointsSynced",
              "value": "={{Object.keys($('Store Sync Data').first().json.data.data || {}).length}}"
            },
            {
              "name": "lastError",
              "value": null
            }
          ]
        },
        "options": {}
      },
      "id": "update-integration-status",
      "name": "Update Integration Status",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [1780, 300],
      "credentials": {
        "httpBearerAuth": {
          "id": "api-token",
          "name": "API Token"
        }
      }
    },
    {
      "parameters": {
        "options": {}
      },
      "id": "check-for-alerts",
      "name": "Check for Health Alerts",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [2000, 300],
      "code": "// Check synced data for health alerts and anomalies\nconst syncResult = $('Store Sync Data').first().json;\nconst insights = syncResult.insights;\nconst userData = syncResult.data;\n\nconst alerts = [];\nconst recommendations = [];\n\n// Check for concerning patterns\nif (insights.dailySteps && insights.dailySteps < 3000) {\n  alerts.push({\n    type: 'low_activity',\n    severity: 'medium',\n    message: 'Daily step count is below recommended minimum (10,000 steps)',\n    value: insights.dailySteps,\n    recommendation: 'Consider taking short walks throughout the day'\n  });\n}\n\nif (insights.avgHeartRate) {\n  if (insights.avgHeartRate > 100) {\n    alerts.push({\n      type: 'elevated_heart_rate',\n      severity: 'high',\n      message: 'Resting heart rate is elevated',\n      value: insights.avgHeartRate,\n      recommendation: 'Monitor closely and consult physician if persistent'\n    });\n  } else if (insights.avgHeartRate < 50) {\n    alerts.push({\n      type: 'low_heart_rate',\n      severity: 'medium',\n      message: 'Resting heart rate is below normal range',\n      value: insights.avgHeartRate,\n      recommendation: 'Consider consulting with a healthcare provider'\n    });\n  }\n}\n\n// Sleep quality check\nif (insights.sleepQuality && insights.sleepQuality === 'poor') {\n  recommendations.push({\n    type: 'sleep_improvement',\n    message: 'Sleep quality could be improved',\n    suggestions: [\n      'Maintain consistent sleep schedule',\n      'Avoid screens 1 hour before bed',\n      'Keep bedroom cool and dark'\n    ]\n  });\n}\n\n// Generate positive reinforcements\nconst positives = [];\nif (insights.dailySteps && insights.dailySteps > 8000) {\n  positives.push('Great job staying active today!');\n}\n\nif (insights.avgHeartRate && insights.avgHeartRate >= 60 && insights.avgHeartRate <= 80) {\n  positives.push('Your heart rate is in a healthy range');\n}\n\nreturn {\n  userId: syncResult.userId,\n  integrationId: syncResult.integrationId,\n  alerts: alerts,\n  recommendations: recommendations,\n  positiveReinforcements: positives,\n  requiresPhysicianAlert: alerts.some(alert => alert.severity === 'high'),\n  analysisTimestamp: new Date().toISOString()\n};"
    }
  ],
  "pinData": {},
  "connections": {
    "Sync Schedule (Every 4 hours)": {
      "main": [
        [
          {
            "node": "Get Active Integrations",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Active Integrations": {
      "main": [
        [
          {
            "node": "Split into Batches",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Split into Batches": {
      "main": [
        [
          {
            "node": "Check Health Integration Type",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Health Integration Type": {
      "main": [
        [
          {
            "node": "Sync Health & Fitness Data",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Sync Weather & AQI Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Sync Health & Fitness Data": {
      "main": [
        [
          {
            "node": "Process Health Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Sync Weather & AQI Data": {
      "main": [
        [
          {
            "node": "Store Sync Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Health Data": {
      "main": [
        [
          {
            "node": "Store Sync Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Store Sync Data": {
      "main": [
        [
          {
            "node": "Update Integration Status",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Integration Status": {
      "main": [
        [
          {
            "node": "Check for Health Alerts",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": true,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "1",
  "meta": {
    "templateCredsSetupCompleted": true
  },
  "id": "external-integrations-sync-workflow",
  "tags": ["integrations", "health-sync", "wearables", "weather", "alerts"]
}